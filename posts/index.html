<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><title>Posts | Bal치zs' blog</title>
<link rel=canonical href=https://balazs.kutilovi.cz/posts/><link href=https://balazs.kutilovi.cz/index.xml rel=alternate type=application/rss+xml title="Bal치zs' blog"><link rel="shortcut icon" type=image/svg+xml href="data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20fill=%22none%22%20viewBox=%220%200%2024%2024%22%20stroke-width=%221.5%22%20stroke=%22currentcolor%22%20color=%22grey%22%3E%3Cpath%20stroke-linecap=%22round%22%20stroke-linejoin=%22round%22%20d=%22M10.34%2015.84c-.688-.06-1.386-.09-2.09-.09H7.5a4.5%204.5.0%20110-9h.75c.704.0%201.402-.03%202.09-.09m0%209.18c.253.962.584%201.892.985%202.783.247.55.06%201.21-.463%201.511l-.657.38c-.551.318-1.26.117-1.527-.461a20.845%2020.845.0%2001-1.44-4.282m3.102.069a18.03%2018.03.0%2001-.59-4.59c0-1.586.205-3.124.59-4.59m0%209.18a23.848%2023.848.0%20018.835%202.535M10.34%206.66a23.847%2023.847.0%20008.835-2.535m0%200A23.74%2023.74.0%200018.795%203m.38%201.125a23.91%2023.91.0%20011.014%205.395m-1.014%208.855c-.118.38-.245.754-.38%201.125m.38-1.125a23.91%2023.91.0%20001.014-5.395m0-3.46c.495.413.811%201.035.811%201.73s-.316%201.317-.811%201.73m0-3.46a24.347%2024.347.0%20010%203.46%22/%3E%3C/svg%3E"><style>/*!modern-normalize v2.0.0 | MIT License | https://github.com/sindresorhus/modern-normalize*/*,::before,::after{box-sizing:border-box}html{font-family:system-ui,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji;line-height:1.15;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4}body{margin:0}hr{height:0;color:inherit}abbr[title]{text-decoration:underline dotted}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:ui-monospace,SFMono-Regular,Consolas,liberation mono,Menlo,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit}button,input,optgroup,select,textarea{font-family:inherit;font-size:100%;line-height:1.15;margin:0}button,select{text-transform:none}button,[type=button],[type=reset],[type=submit]{-webkit-appearance:button}::-moz-focus-inner{border-style:none;padding:0}:-moz-focusring{outline:1px dotted ButtonText}:-moz-ui-invalid{box-shadow:none}legend{padding:0}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}</style><style>html{line-height:1.5}h1{font-size:2.136rem}h2{font-size:1.898rem}h3{font-size:1.688rem}body{max-width:32rem;padding:.74rem;margin:auto}blockquote{margin-left:1.688rem;padding-left:.74rem;border-left:.461rem #ddd solid}p code{font-size:.936rem;margin:0 .288rem}img{max-width:100%;height:auto}pre{font-size:.74rem;margin:1.688rem 0;padding:.936rem;overflow-x:scroll}footer{margin:1.688rem 0}footer nav{margin:1.688rem 0}</style></head><body><header><h1>Bal치zs' blog</h1><nav><span><a href=/>Posts</a>
</span><span><a href=/about/>About</a></span></nav></header><main><h2>Posts</h2><h3><a href=/posts/tracking-down-a-memory-leak/>Tracking down a memory leak</a></h3>Tl;Dr: I followed this guide to debug a memory leak in a Sidekiq job. In my case, the leak was caused by a thread local array buffer in lograge-sql that never got cleared.
With PlainAPM infra moved away from Heroku, one of the first monitors I implemented were for the app&rsquo;s memory, as previously Heroku metrics showed a persistent growth for the Sidekiq process:
Initially, I thought it was a memory fragmentation issue, and that the process is allocating objects in a way that doesn&rsquo;t allow releasing the memory back to the OS.<h3><a href=/posts/handling-process-forks-with-threads/>Handling forks in threaded code in Ruby</a></h3>In MRI Ruby, when calling a Process.fork, only the main thread gets copied into the child process, while the other threads will appear as &lsquo;dead&rsquo;.
In my case, it was a Thread::Queue serviced by a Thread worker loop initialized in puma which then forked b/c it was set up in cluster mode, and I saw things not being processed as they should.
However, it turns out that this is a documented behavior, and I&rsquo;m probably not alone getting caught off-guard by this.<h3><a href=/posts/whats-the-time/>What's the time?</a></h3>I&rsquo;ve been running some profiling on the PlainApm agent and one of the things that sometimes popped up in the stackprof output were calls to (Date)Time#iso8601. I used them to get an idea of the overall pipeline latency from the moment the event gets collected until it gets written to the DB.
It turns out that these calls are indeed quite slow, so depending on the use case, Time.now.to_f or Process.<h3><a href=/posts/how-not-to-benchmark-a-rails-app/>How Not to Benchmark a Rails App</a></h3>It starts with &ldquo;I&rsquo;m just going to use benchmark/ips and openuri, its just a couple lines of code&rdquo;.
So you copy over config/environments/production.rb to config/environments/benchmark.rb to have the same settings, disable SSL, add a prefix to assets path to avoid interfering w/ development, add a DB configuration for the new env, run RAILS_ENV=benchmark rails db:setup and RAILS_ENV=benchmark rails assets:precompile.
Whip up a trivial rake task:
require 'benchmark/ips' namespace :traffic do desc "Benchmark the app" task :benchmark do Benchmark.<h3><a href=/posts/ruby-internal-types/>Ruby Internal Types</a></h3>While working on PlainAPM&rsquo;s object allocation tracing callback, I needed a way to determine classes of arbitrary objects returned by rb_tracearg_object.
The naive way, calling rb_obj_classname was segfaulting, though, so I decided to handle this type-by-type, and either avoid the problem, or narrow down the scope of the issue, to understand it better.
Here are some notes that might save fifteen minutes to a future me, or to someone who&rsquo;s starting to look into which types of objects are there in Ruby:<h3><a href=/posts/dtracing-the-ruby-gvl/>DTracing the Ruby GVL</a></h3>Nate Berkopec posted an interesting question on twitter:
Puma office hours: we want to measure what % of the time the global VM lock is held in a Ruby process. anyone got an idea on how to even start to observe that, performantly? #railsconf
I thought about using &lsquo;dtrace&rsquo; immediately, since I already experimented with adding custom probes to MRI Ruby a few years back.
With that I set out to patch MRI to allow for this.<h3><a href=/posts/notes-from-rubyconf-au-talks/>Notes from RubyConf 2017 AU talks</a></h3>Reinvesting in Ruby by Tim Riley Video
Rails was defining the Ruby ecosystem, time to explore other alternatives Introduces dry-rb gems on a blog post example Minimalistic, single-responsibility, composable gems for common tasks dry-validation, dry-monads, dry-matcher - pattern matching Actors in Ruby! Why let Elixir have all the fun by Marcos Matos Video
Threads vs. forks (forks heavy - even with CoW optimisations). Forking does not have built-in way to communicate - some form of IPC is required, e.<h3><a href=/posts/ruby-tracing-part-two-rbtrace/>Ruby tracing part two - rbtrace</a></h3>In a previous post, I looked at how Linux&rsquo;s eBPF framework can be used with Ruby.
Of course TIMTOWTDI!
So, it turns out there&rsquo;s an excellent gem for Ruby tracing: rbtrace by Aman Gupta, which I encountered a few months ago, in Sam Saffron&rsquo;s post when I needed to get a heap dump from a Ruby process to track down a memory leak.
rbtrace Justin Weiss wrote up a summary with some cool examples of what the gem can do, but in a nutshell:<h3><a href=/posts/ruby-tracing-part-one-bpf/>Ruby tracing part one - BPF</a></h3>How many times did you need to ssh into production, and see what the Ruby app is actually doing now? How it allocates memory, which syscalls or what user-level functions is it calling?
Even with centralized logging, the granularity is less than ideal for observing performance, or even bugs in the wild. What you usually get is an after-the-fact summary of state, maybe requests per second report, maybe an exception and a backtrace.<h3><a href=/posts/printf-debugging-basics-in-ruby/>Printf debugging basics in Ruby</a></h3>Sometimes, a printf is enough. Although IDEs usually integrate with a debugger and allow you to setup complex breakpoints, the power of printing out statements shouldn&rsquo;t be underestimated. The learning curve is low and all the required tools are there. No need to install gems, or spend money on an IDE.
Let&rsquo;s look at some printf style tools that&rsquo;s good to have in your debugging toolbox. We&rsquo;ll be going from the simplest ones for inspecting objects, logging, going through execution context and looking up definitions of methods.</main><footer><div><a href=https://balazs.kutilovi.cz/index.xml title="Bal치zs' blog" target=_blank>RSS</a>
<a href=https://twitter.com/balazs_kutil target=_blank>Twitter</a>
<a rel=me href=https://ruby.social/@balazs target=_blank>Mastodon</a>
<a href=https://linkedin.com/in/balazs-kutil target=_blank>Linkedin</a>
<a href=https://github.com/bkutil target=_blank>GitHub</a></div></footer></body></html>