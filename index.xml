<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Balázs' blog</title><link>https://balazs.kutilovi.cz/</link><description>Recent content in Posts on Balázs' blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 04 Mar 2024 08:04:30 +0100</lastBuildDate><atom:link href="https://balazs.kutilovi.cz/index.xml" rel="self" type="application/rss+xml"/><item><title>What's the time?</title><link>https://balazs.kutilovi.cz/posts/whats-the-time/</link><pubDate>Mon, 04 Mar 2024 08:04:30 +0100</pubDate><guid>https://balazs.kutilovi.cz/posts/whats-the-time/</guid><description>I&amp;rsquo;ve been running some profiling on the PlainApm agent and one of the things that sometimes popped up in the stackprof output were calls to (Date)Time#iso8601. I used them to get an idea of the overall pipeline latency from the moment the event gets collected until it gets written to the DB.
It turns out that these calls are indeed quite slow, so depending on the use case, Time.now.to_f or Process.</description></item><item><title>How Not to Benchmark a Rails App</title><link>https://balazs.kutilovi.cz/posts/how-not-to-benchmark-a-rails-app/</link><pubDate>Tue, 27 Feb 2024 07:04:30 +0100</pubDate><guid>https://balazs.kutilovi.cz/posts/how-not-to-benchmark-a-rails-app/</guid><description>It starts with &amp;ldquo;I&amp;rsquo;m just going to use benchmark/ips and openuri, its just a couple lines of code&amp;rdquo;.
So you copy over config/environments/production.rb to config/environments/benchmark.rb to have the same settings, disable SSL, add a prefix to assets path to avoid interfering w/ development, add a DB configuration for the new env, run RAILS_ENV=benchmark rails db:setup and RAILS_ENV=benchmark rails assets:precompile.
Whip up a trivial rake task:
require &amp;#39;benchmark/ips&amp;#39; namespace :traffic do desc &amp;#34;Benchmark the app&amp;#34; task :benchmark do Benchmark.</description></item><item><title>Ruby Internal Types</title><link>https://balazs.kutilovi.cz/posts/ruby-internal-types/</link><pubDate>Fri, 23 Feb 2024 20:09:28 +0100</pubDate><guid>https://balazs.kutilovi.cz/posts/ruby-internal-types/</guid><description>While working on PlainAPM&amp;rsquo;s object allocation tracing callback, I needed a way to determine classes of arbitrary objects returned by rb_tracearg_object.
The naive way, calling rb_obj_classname was segfaulting, though, so I decided to handle this type-by-type, and either avoid the problem, or narrow down the scope of the issue, to understand it better.
Here are some notes that might save fifteen minutes to a future me, or to someone who&amp;rsquo;s starting to look into which types of objects are there in Ruby:</description></item><item><title>DTracing the Ruby GVL</title><link>https://balazs.kutilovi.cz/posts/dtracing-the-ruby-gvl/</link><pubDate>Tue, 07 May 2019 20:12:36 +0000</pubDate><guid>https://balazs.kutilovi.cz/posts/dtracing-the-ruby-gvl/</guid><description>Nate Berkopec posted an interesting question on twitter:
Puma office hours: we want to measure what % of the time the global VM lock is held in a Ruby process. anyone got an idea on how to even start to observe that, performantly? #railsconf
I thought about using &amp;lsquo;dtrace&amp;rsquo; immediately, since I already experimented with adding custom probes to MRI Ruby a few years back.
With that I set out to patch MRI to allow for this.</description></item><item><title>Notes from RubyConf 2017 AU talks</title><link>https://balazs.kutilovi.cz/posts/notes-from-rubyconf-au-talks/</link><pubDate>Mon, 24 Apr 2017 05:11:03 +0000</pubDate><guid>https://balazs.kutilovi.cz/posts/notes-from-rubyconf-au-talks/</guid><description>Reinvesting in Ruby by Tim Riley Video
Rails was defining the Ruby ecosystem, time to explore other alternatives Introduces dry-rb gems on a blog post example Minimalistic, single-responsibility, composable gems for common tasks dry-validation, dry-monads, dry-matcher - pattern matching Actors in Ruby! Why let Elixir have all the fun by Marcos Matos Video
Threads vs. forks (forks heavy - even with CoW optimisations). Forking does not have built-in way to communicate - some form of IPC is required, e.</description></item><item><title>Ruby tracing part two - rbtrace</title><link>https://balazs.kutilovi.cz/posts/ruby-tracing-part-two-rbtrace/</link><pubDate>Sat, 04 Feb 2017 14:37:10 +0100</pubDate><guid>https://balazs.kutilovi.cz/posts/ruby-tracing-part-two-rbtrace/</guid><description>In a previous post, I looked at how Linux&amp;rsquo;s eBPF framework can be used with Ruby.
Of course TIMTOWTDI!
So, it turns out there&amp;rsquo;s an excellent gem for Ruby tracing: rbtrace by Aman Gupta, which I encountered a few months ago, in Sam Saffron&amp;rsquo;s post when I needed to get a heap dump from a Ruby process to track down a memory leak.
rbtrace Justin Weiss wrote up a summary with some cool examples of what the gem can do, but in a nutshell:</description></item><item><title>Ruby tracing part one - BPF</title><link>https://balazs.kutilovi.cz/posts/ruby-tracing-part-one-bpf/</link><pubDate>Sat, 28 Jan 2017 17:16:15 +0100</pubDate><guid>https://balazs.kutilovi.cz/posts/ruby-tracing-part-one-bpf/</guid><description>How many times did you need to ssh into production, and see what the Ruby app is actually doing now? How it allocates memory, which syscalls or what user-level functions is it calling?
Even with centralized logging, the granularity is less than ideal for observing performance, or even bugs in the wild. What you usually get is an after-the-fact summary of state, maybe requests per second report, maybe an exception and a backtrace.</description></item><item><title>Printf debugging basics in Ruby</title><link>https://balazs.kutilovi.cz/posts/printf-debugging-basics-in-ruby/</link><pubDate>Thu, 26 Jan 2017 06:02:12 +0100</pubDate><guid>https://balazs.kutilovi.cz/posts/printf-debugging-basics-in-ruby/</guid><description>Sometimes, a printf is enough. Although IDEs usually integrate with a debugger and allow you to setup complex breakpoints, the power of printing out statements shouldn&amp;rsquo;t be underestimated. The learning curve is low and all the required tools are there. No need to install gems, or spend money on an IDE.
Let&amp;rsquo;s look at some printf style tools that&amp;rsquo;s good to have in your debugging toolbox. We&amp;rsquo;ll be going from the simplest ones for inspecting objects, logging, going through execution context and looking up definitions of methods.</description></item></channel></rss>