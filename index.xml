<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Balázs' blog</title><link>https://balazs.kutilovi.cz/</link><description>Recent content in Posts on Balázs' blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 07 May 2019 20:12:36 +0000</lastBuildDate><atom:link href="https://balazs.kutilovi.cz/index.xml" rel="self" type="application/rss+xml"/><item><title>DTracing the Ruby GVL</title><link>https://balazs.kutilovi.cz/posts/dtracing-the-ruby-gvl/</link><pubDate>Tue, 07 May 2019 20:12:36 +0000</pubDate><guid>https://balazs.kutilovi.cz/posts/dtracing-the-ruby-gvl/</guid><description>Nate Berkopec posted an interesting question on twitter:
Puma office hours: we want to measure what % of the time the global VM lock is held in a Ruby process. anyone got an idea on how to even start to observe that, performantly? #railsconf
I thought about using &amp;lsquo;dtrace&amp;rsquo; immediately, since I already experimented with adding custom probes to MRI Ruby a few years back.
With that I set out to patch MRI to allow for this.</description></item><item><title>Notes from RubyConf 2017 AU talks</title><link>https://balazs.kutilovi.cz/posts/notes-from-rubyconf-au-talks/</link><pubDate>Mon, 24 Apr 2017 05:11:03 +0000</pubDate><guid>https://balazs.kutilovi.cz/posts/notes-from-rubyconf-au-talks/</guid><description>Reinvesting in Ruby by Tim Riley Video
Rails was defining the Ruby ecosystem, time to explore other alternatives Introduces dry-rb gems on a blog post example Minimalistic, single-responsibility, composable gems for common tasks dry-validation, dry-monads, dry-matcher - pattern matching Actors in Ruby! Why let Elixir have all the fun by Marcos Matos Video
Threads vs. forks (forks heavy - even with CoW optimisations). Forking does not have built-in way to communicate - some form of IPC is required, e.</description></item><item><title>Ruby tracing part two - rbtrace</title><link>https://balazs.kutilovi.cz/posts/ruby-tracing-part-two-rbtrace/</link><pubDate>Sat, 04 Feb 2017 14:37:10 +0100</pubDate><guid>https://balazs.kutilovi.cz/posts/ruby-tracing-part-two-rbtrace/</guid><description>In a previous post, I looked at how Linux&amp;rsquo;s eBPF framework can be used with Ruby.
Of course TIMTOWTDI!
So, it turns out there&amp;rsquo;s an excellent gem for Ruby tracing: rbtrace by Aman Gupta, which I encountered a few months ago, in Sam Saffron&amp;rsquo;s post when I needed to get a heap dump from a Ruby process to track down a memory leak.
rbtrace Justin Weiss wrote up a summary with some cool examples of what the gem can do, but in a nutshell:</description></item><item><title>Ruby tracing part one - BPF</title><link>https://balazs.kutilovi.cz/posts/ruby-tracing-part-one-bpf/</link><pubDate>Sat, 28 Jan 2017 17:16:15 +0100</pubDate><guid>https://balazs.kutilovi.cz/posts/ruby-tracing-part-one-bpf/</guid><description>How many times did you need to ssh into production, and see what the Ruby app is actually doing now? How it allocates memory, which syscalls or what user-level functions is it calling?
Even with centralized logging, the granularity is less than ideal for observing performance, or even bugs in the wild. What you usually get is an after-the-fact summary of state, maybe requests per second report, maybe an exception and a backtrace.</description></item><item><title>Printf debugging basics in Ruby</title><link>https://balazs.kutilovi.cz/posts/printf-debugging-basics-in-ruby/</link><pubDate>Thu, 26 Jan 2017 06:02:12 +0100</pubDate><guid>https://balazs.kutilovi.cz/posts/printf-debugging-basics-in-ruby/</guid><description>Sometimes, a printf is enough. Although IDEs usually integrate with a debugger and allow you to setup complex breakpoints, the power of printing out statements shouldn&amp;rsquo;t be underestimated. The learning curve is low and all the required tools are there. No need to install gems, or spend money on an IDE.
Let&amp;rsquo;s look at some printf style tools that&amp;rsquo;s good to have in your debugging toolbox. We&amp;rsquo;ll be going from the simplest ones for inspecting objects, logging, going through execution context and looking up definitions of methods.</description></item></channel></rss>